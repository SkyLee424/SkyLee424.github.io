<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on Sky_Lee 的个人博客</title>
    <link>http://localhost:1313/categories/redis/</link>
    <description>Recent content in Redis on Sky_Lee 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Sky_Lee</copyright>
    <lastBuildDate>Sun, 10 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis 杂项</title>
      <link>http://localhost:1313/posts/redis/%E6%9D%82%E9%A1%B9/note/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E6%9D%82%E9%A1%B9/note/</guid>
      <description>Redis 事务 基本使用 redis 的事务与传统关系性数据库的事务不同，没有 ACID 特性 开启事务可以使用 MULTI 命令 回滚事务可以使用 DISCARD 命令 提交事务可以使用 EXEC 命令 为了防止多客</description>
    </item>
    <item>
      <title>Redis 集群</title>
      <link>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/note/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/note/</guid>
      <description>为什么要使用 Redis 集群 前面的文章 提到了基于 哨兵集群 的「一主多从」模型 这种模型实际上也是一种 Redis 集群，优点如下： 实现数据的冗余备份 基于故障转移，可以</description>
    </item>
    <item>
      <title>缓存的几种操作模式</title>
      <link>http://localhost:1313/posts/redis/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F/note/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F/note/</guid>
      <description>Cache-Aside 应用代码需要首先在缓存中查找数据，如果未找到，再从数据库中加载数据，并将其添加到缓存中。 当应用程序需要修改 DB 的数据，只需要先更新 DB，再删</description>
    </item>
    <item>
      <title>缓存雪崩、缓存击穿、缓存穿透</title>
      <link>http://localhost:1313/posts/redis/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/note/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/note/</guid>
      <description>缓存雪崩 缓存雪崩指的是大量 key 几乎同时过期，导致大量请求直接打到 DB，导致 DB 服务不可用，进而导致其它服务也不可用，就像雪崩一样 应对方式 给 Key 指定</description>
    </item>
    <item>
      <title>Redis 主从复制（同步）</title>
      <link>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5/note/</link>
      <pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5/note/</guid>
      <description>介绍 Redis 主从复制（同步）是指将一个 Redis 服务器的数据复制（同步）到多个 Redis 服务器的过程。这样，当主服务器出现故障时，其他从服务器可以接管其工作，从而</description>
    </item>
    <item>
      <title>Redis 哨兵</title>
      <link>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/note/</link>
      <pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E5%93%A8%E5%85%B5/note/</guid>
      <description>为什么要有哨兵 Redis 哨兵主要负责： 集群健康状态监测 集群故障转移 通知 可以说，Redis 的高可用离不开哨兵 如何判断主节点故障 主观下线 前面提到，哨兵具</description>
    </item>
    <item>
      <title>Redis 常见数据结构与实现原理</title>
      <link>http://localhost:1313/posts/redis/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/note/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/note/</guid>
      <description>底层数据结构 SDS（简单动态字符串） 传统的 C 字符串存在以下问题： 获取 strlen 效率低 无法存储文本以外的数据（二进制不安全） 不支持动态扩容，appen</description>
    </item>
    <item>
      <title>Redis 持久化机制</title>
      <link>http://localhost:1313/posts/redis/%E6%8C%81%E4%B9%85%E5%8C%96/note/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E6%8C%81%E4%B9%85%E5%8C%96/note/</guid>
      <description>AOF 日志 介绍 AOF（append-only file）是 Redis 持久化数据的一种策略 由于 Redis 的数据都存在内存，如果不做持久化，重启后数据就丢失了 AOF 的机制</description>
    </item>
    <item>
      <title>Redis 过期删除与内存淘汰策略</title>
      <link>http://localhost:1313/posts/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/note/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/note/</guid>
      <description>过期删除策略 Redis 实际上使用了一个哈希表来记录每个 key 的过期时间 在给 Redis 的 key 设置 TTL，实际上就是新增（修改）哈希表中的数据 在获取 key 的 value 时，首先要先</description>
    </item>
  </channel>
</rss>
