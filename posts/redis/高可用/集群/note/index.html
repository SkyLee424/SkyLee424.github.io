<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>Redis 集群 - Sky_Lee 的个人博客</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="为什么要使用 Redis 集群 前面的文章 提到了基于 哨兵集群 的「一主多从」模型 这种模型实际上也是一种 Redis 集群，优点如下： 实现数据的冗余备份 基于故障转移，可以"
/>
<meta
  name="keywords"
  content="Sky_Lee, 博客, blogs"
/>
<meta name="robots" content="noodp" />
<meta property="og:title" content="Redis 集群" />
<meta property="og:description" content="Redis Cluster 的介绍" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/note/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-03-10T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Redis 集群"/>
<meta name="twitter:description" content="Redis Cluster 的介绍"/>


<link rel="canonical" href="http://localhost:1313/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/note/" />

<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/css/index.2a207ca2c2522fbda3cf133d0ddac63fa4d104ff62926179b8346499d49fe5bd.css">









  
</head>
<body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800">
  <header class="flex flex-none justify-center z-10">
    <div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3">
  <div class="flex-none ml-2 md:ml-0">
    <a href="/" class="">
      <img class="h-12 w-12 rounded-full object-cover bg-gray-100" src="http://images.bluebell.skylee.top/bluebell%2Favatar%2F0ae39267eb81693c01509301b7278638d9e540dc18e99e64c071ad0f1c705f60" alt="logo">
    </a>
  </div>
  <div class="flex-1"></div>
  <div class="flex-none">
    



<nav class="h-full static">
  <button id="navbar-menu-toggle" type="button" class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls="navbar-menu" aria-expanded="false">
    <span class="sr-only">Open main menu</span>
    <i class="w-8 h-8">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 6l16 0" />
  <path d="M4 12l16 0" />
  <path d="M4 18l16 0" />
</svg>

    </i>
  </button>
  <div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id="navbar-menu">
    <ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5">
    
        <li id="about" class="">
          <a class="block px-3 py-3 hover:text-emerald-600"
            href="/about/" title="About">About</a>
        </li>
      
    
        <li id="post" class="">
          <a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600"
            href="/posts/" title="Post">Post</a>
        </li>
      
    
    </ul>
  </div>
</nav>


  </div>
  
  <div class="flex-none mx-1"></div>
  
  <div class="flex-none md:hidden">
    <a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls="navbar-menu" aria-expanded="false">
      <span class="sr-only">Search</span>
      <i class="w-8 h-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />
    <path d="M21 21l-6 -6" />
</svg>

      </i>
    </a>
  </div>
  <div class="darkmode-toggle flex flex-none mr-2 md:mr-0">
    <label for="darkmode-toggle" class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode">
      <input name="darkmode-toggle" id="darkmode-toggle" type="checkbox" class="sr-only peer" aria-label="Toggle dark mode">
      <div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700">
        <i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
   <path d="M12 5l0 .01"></path>
   <path d="M17 7l0 .01"></path>
   <path d="M19 12l0 .01"></path>
   <path d="M17 17l0 .01"></path>
   <path d="M12 19l0 .01"></path>
   <path d="M7 17l0 .01"></path>
   <path d="M5 12l0 .01"></path>
   <path d="M7 7l0 .01"></path>
</svg>

        </i>
        <i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
   <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
   <path d="M19 11h2m-1 -1v2"></path>
</svg>

        </i>
      </div>
    </label>
  </div>
</div>

  </header>
  <main class="flex flex-auto justify-center">
    
<div class="w-full max-w-4xl lg:max-w-5xl">
  <div class="flex flex-col gap-y-3 p-6 mt-6 mx-2 md:mx-0 rounded-lg shadow-md bg-white dark:bg-gray-700">
    <h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100">
      <a href="/posts/redis/%E9%AB%98%E5%8F%AF%E7%94%A8/%E9%9B%86%E7%BE%A4/note/">Redis 集群</a>
    </h1>

    
    <h2 class="my-4 text-large text-slate-600 dark:text-slate-300">
      Redis Cluster 的介绍
    </h2>
    
    
  <ul class="flex flex-row flex-wrap text-slate-500 dark:text-slate-300">
    
      
      <li>
        <a href="/categories/redis/"
          class="text-sm mr-2 px-2 py-1 rounded border border-emerald-800 bg-emerald-800 text-slate-50">
          Redis
        </a>
      </li>
      
    
    
      
      <li>
        <a href="/tags/redis/"
          class="flex flex-row text-sm mr-2 py-1">
          <i class="h-5 w-5 flex-none">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M5 9l14 0"></path>
   <path d="M5 15l14 0"></path>
   <path d="M11 4l-4 16"></path>
   <path d="M17 4l-4 16"></path>
</svg>

          </i>
          <span class="ml-0">Redis</span>
        </a>
      </li>
      
      <li>
        <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"
          class="flex flex-row text-sm mr-2 py-1">
          <i class="h-5 w-5 flex-none">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M5 9l14 0"></path>
   <path d="M5 15l14 0"></path>
   <path d="M11 4l-4 16"></path>
   <path d="M17 4l-4 16"></path>
</svg>

          </i>
          <span class="ml-0">高可用</span>
        </a>
      </li>
      
      <li>
        <a href="/tags/cluster/"
          class="flex flex-row text-sm mr-2 py-1">
          <i class="h-5 w-5 flex-none">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M5 9l14 0"></path>
   <path d="M5 15l14 0"></path>
   <path d="M11 4l-4 16"></path>
   <path d="M17 4l-4 16"></path>
</svg>

          </i>
          <span class="ml-0">Cluster</span>
        </a>
      </li>
      
    
  </ul>



    <div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300">
  
  
  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4 7a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12z"></path>
   <path d="M16 3v4"></path>
   <path d="M8 3v4"></path>
   <path d="M4 11h16"></path>
   <path d="M11 15h1"></path>
   <path d="M12 15v3"></path>
</svg>

    </i>
    <time datetime="2024-03-10T00:00:00&#43;00:00">
      2024-03-10
    </time>
  </div>

  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M6.5 7h11"></path>
   <path d="M6 20v-2a6 6 0 1 1 12 0v2a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1z"></path>
   <path d="M6 4v2a6 6 0 1 0 12 0v-2a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1z"></path>
</svg>

    </i>
    <span>
      17 minutes to read
    </span>
  </div>
</div>


    

    <article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content">
      <h2 id="为什么要使用-redis-集群">为什么要使用 Redis 集群</h2>
<p><a href="http://bluebell.skylee.top/#/post/53114396997586944" target="_blank" rel="noopener">前面的文章</a>
 提到了基于 <a href="http://bluebell.skylee.top/#/post/53114106693029888" target="_blank" rel="noopener">哨兵集群</a>
 的「一主多从」模型</p>
<p>这种模型实际上也是一种 Redis 集群，优点如下：</p>
<ul>
<li>实现数据的冗余备份</li>
<li>基于故障转移，可以保证一定程度的可用性</li>
<li>读写分离，提高整体读取性能</li>
</ul>
<p>但是，这种模型存在一个严重的问题：<strong>只有一个主节点</strong>，所有的写请求都是直接发到主节点上，主节点压力很大，如果写请求 QPS 很高，很有可能导致主节点撑不住，然后挂掉</p>
<p>针对这种情况，Redis <strong>原生</strong> 支持了 Redis 集群模式（Redis Cluster），这种模式往往有多个主节点，并且每个主节点还有一些从节点来保证可用性</p>
<p>下面的文章，会基于 <a href="https://redis.io/docs/reference/cluster-spec" target="_blank" rel="noopener">Redis 官方文档</a>
 来简要介绍 Redis 集群</p>
<h2 id="redis-集群实现了什么功能">Redis 集群实现了什么功能</h2>
<blockquote>
<ul>
<li><strong>High performance and linear scalability up to 1000 nodes</strong>. There are no proxies, asynchronous replication is used, and no merge operations are performed on values.</li>
<li>Acceptable degree of <strong>write safety</strong>: the system tries (in a best-effort way) to retain all the writes originating from clients connected with the majority of the master nodes. Usually there are small windows where acknowledged writes can be lost. Windows to lose acknowledged writes are larger when clients are in a minority partition.</li>
<li><strong>Availability</strong>: Redis Cluster is able to survive partitions where the majority of the master nodes are reachable and there is at least one reachable replica for every master node that is no longer reachable. Moreover using replicas migration, masters no longer replicated by any replica will receive one from a master which is covered by multiple replicas.</li>
</ul>
</blockquote>
<p>简单来说，Redis Cluster 实现了：</p>
<ul>
<li>高性能：支持扩展至高 1k+ 节点</li>
<li>写入安全保障：在保证性能的同时，有一定的写入安全保障（可能会丢失一部分数据）</li>
<li>高可用：基于副本迁移，只要有足够的从节点，Redis 集群能保证服务的可用性</li>
</ul>
<p>但是，在 Cluster 模式下，Redis 不支持 <code>select</code> 操作，这意味着只能有 DB0</p>
<h2 id="在-redis-cluster-协议下server-与-client-在-redis-集群中的身份">在 Redis Cluster 协议下，Server 与 Client 在 Redis 集群中的身份</h2>
<blockquote>
<p>To perform their tasks all the cluster nodes are connected using a TCP bus and a binary protocol, called the Redis <strong>Cluster Bus</strong>. Every node is connected to every other node in the cluster using the cluster bus. Nodes use a gossip protocol to propagate information about the cluster in order to discover new nodes, to send ping packets to make sure all the other nodes are working properly, and to send cluster messages needed to signal specific conditions. The cluster bus is also used in order to propagate Pub/Sub messages across the cluster and to orchestrate manual failovers when requested by users (manual failovers are failovers which are not initiated by the Redis Cluster failure detector, but by the system administrator directly)</p>
</blockquote>
<p>Server 与 Client 之间，通过基于 TCP 的 Redis Serialization Protocol 协议建立连接</p>
<p>而所有的 Cluster 节点之间，通过 <a href="#cluster-bus">Cluster Bus</a>
 连接，节点之间使用 gossip 协议通信，目的是为了：</p>
<ul>
<li>发现新节点</li>
<li>检测彼此的健康状态（服务是否可用）</li>
<li>在节点间发送信号，提供所需的集群消息</li>
</ul>
<p><div class="not-prose">
<figure>
    <img src="http://images.blogs.skylee.top/2024-03-09-17-20-28-970.png"
      alt="image" 
      loading="lazy"
    >
  </figure></div>
</p>
<blockquote>
<p>每个节点都要与其它节点建立 TCP 连接，应该是 5 条边才对</p>
<p>这里的图片，为了看起来不太乱，每个节点都少画了两条边</p>
</blockquote>
<blockquote>
<p>The client is in theory free to send requests to all the nodes in the cluster, getting redirected if needed, so the client <strong>is not required to hold the state of the cluster.</strong> However clients that are able to <strong>cache the map between keys and nodes</strong> can improve the performance in a sensible way.</p>
</blockquote>
<p>客户端向 Redis 集群发送读写请求时，只需要连接任意一个节点，如果要操作的数据不在这个节点上，请求会被重定向到目标节点上</p>
<p>当然，为了避免重定向的性能开销，Redis 的客户端会在建立连接时，<strong>将数据与节点的映射关系缓存到本地</strong></p>
<h2 id="如何减少数据丢失">如何减少数据丢失</h2>
<blockquote>
<p>Writes targeting the minority side of a partition have a larger window in which to get lost. For example, Redis Cluster loses a non-trivial number of writes on partitions where there is a minority of masters and at least one or more clients, since all the writes sent to the masters may potentially get lost <strong>if the masters are failed over</strong> in the majority side.</p>
</blockquote>
<ul>
<li>一种情况就是在主节点向从节点同步增量数据时，主节点挂了，导致的数据丢失，比较随机，不太好避免</li>
<li>还有一种情况就是常说的「脑裂」现象，即由于网络问题，集群内其它节点误认为主节点挂了</li>
</ul>
<p>于是执行故障转移，选出新的主节点，此时就有两个主节点了（当然，原先的主节点由于网络问题，无法感知）</p>
<p>等到原先的主节点的网络恢复以后，集群会以为原先的主节点上线了，于是让原先的主节点降级为新的主节点的从节点</p>
<blockquote>
<p>那么数据丢失发生在哪里呢？</p>
</blockquote>
<p>集群误认为主节点宕机，这个过程是需要时间的</p>
<p>对客户端来说，此时是不知道集群内部网络不好的，还是会正常发送写请求</p>
<p>假设主节点收到了这些写请求，肯定要同步给从节点，但由于内部网络问题，<strong>无法完成同步</strong></p>
<p>如果内部网络迟迟不恢复，那么在完成同步之前，就选出了新的主节点，原来的主节点降级后，这部分增量数据就会丢失</p>
<blockquote>
<p>如何减少数据丢失？</p>
</blockquote>
<p>Redis 是这样做的：</p>
<blockquote>
<p>Specifically, for a master to be failed over it must be unreachable by the majority of masters for at least NODE_TIMEOUT, so if the partition is <strong>fixed before that time, no writes are lost.</strong> When the partition lasts for more than NODE_TIMEOUT, all the writes performed in the minority side up to that point may be lost. However the minority side of a Redis Cluster will start refusing writes as soon as NODE_TIMEOUT time has elapsed without contact with the majority, so there is a maximum window after which the minority becomes no longer available.</p>
</blockquote>
<p>可以调整 <code>NODE_TIMEOUT</code> 参数</p>
<p>假设集群检测到主节点疑似宕机的时间为 t0，主节点恢复时间为 t1</p>
<ul>
<li>如果 t1 在 t0 + <code>NODE_TIMEOUT</code> 前，那么不会有数据丢失，因为不会选举新的主节点</li>
<li>否则，根据与从节点的同步情况，会丢失未同步给所有从节点的增量数据</li>
</ul>
<h2 id="高可用">高可用</h2>
<p>Redis Cluster 有 <strong>故障转移</strong> 的能力</p>
<p>这个故障转移的过程与 <em>基于哨兵的故障转移</em> 过程很类似</p>
<p>以 5 主 5 从（即每一个主节点都有一个从节点）为例，假设掉了两个节点，那么只有：</p>
<ul>
<li>掉了一个主节点</li>
<li>该主节点的从节点也挂了</li>
</ul>
<p>这种情况，整个 Redis Cluster 服务才会不可用，概率为 <code>(5*2)/(10*9) = 11%</code></p>
<p>当然如果是 5 主 6 从（即有一个主节点具有两个从节点），情况就不一样了</p>
<blockquote>
<p>Thanks to a Redis Cluster feature called <strong>replicas migration</strong> the Cluster availability is improved in many real world scenarios by the fact that replicas migrate to orphaned masters (masters no longer having replicas).</p>
<p>So at every successful failure event, the cluster may reconfigure the replicas layout in order to better resist the next failure.</p>
</blockquote>
<p>Redis 引入了 <a href="#%e5%89%af%e6%9c%ac%e8%bf%81%e7%a7%bbreplica-migration">副本迁移</a>
 机制，在检测到 <strong>孤儿主节点</strong> 时会触发，将其它主节点的部分从节点迁移到孤儿主节点，进一步保证可用性</p>
<h2 id="高性能">高性能</h2>
<blockquote>
<p>Very high performance and scalability while preserving weak but reasonable forms of data safety and availability is the main goal of Redis Cluster.</p>
</blockquote>
<p>Redis 集群的主要目标是在保持数据安全性和可用性的同时，提供非常高的性能和可伸缩性。进一步的，以下几个因素保证了 Redis Cluster 的高性能：</p>
<ul>
<li>客户端缓存 key 与 node 的关系</li>
<li>异步复制</li>
<li>线性扩展能力（n 个主节点的集群的性能，可以看作单个主节点性能的 n 倍）</li>
</ul>
<p><strong>客户端缓存 key 与 node 的关系</strong></p>
<p>任意 Redis Cluster 节点收到 Client 的请求后：</p>
<ul>
<li>检查这个 key 的 value 是否在本节点上，如果在，那就由自己处理</li>
<li>否则，将客户端的请求正确重定向到目标节点</li>
</ul>
<p>为了提高性能，客户端会在本地缓存 key 与 node 的映射关系（即一个哈希表），具体来说：</p>
<ul>
<li>key：hash slots</li>
<li>value：&lt;node_ip, node_port&gt;</li>
</ul>
<p>例如，假设 clusterA 负责 hash slots 在 (114, 514) 的数据，那么客户端就会缓存像这样的内容：</p>
<ul>
<li>key：114 ～ 514</li>
<li>value：&lt;cluterA&rsquo;s IP, cluterA&rsquo;s Port&gt;</li>
</ul>
<p>那么，客户端在发起请求前，会先计算 key 对应的 hash slots，然后请求对应的节点，避免一次重定向</p>
<p>当然，这个缓存可能会过期，此时就还是要依赖 cluster 的重定向了</p>
<h2 id="redis-集群的基本组件">Redis 集群的基本组件</h2>
<h3 id="key-distribution-model">Key distribution model</h3>
<p>实现数据的分片，依赖的就是 key 分发模型</p>
<p>Redis 给整个集群分配了 16384 个哈希槽（hash slots），每个 cluster 节点都拥有一部分 hash slots</p>
<p>确定 key 在哪个 hash slot，这个过程使用 CRC16 算法，具体来说：</p>
<pre tabindex="0"><code>hash_slot = CRC16(key) % 16384
</code></pre><p>在客户端读写数据时：</p>
<ul>
<li>先计算出 hash slot</li>
<li>读取本地缓存，获取这个 hash slot 在哪个 cluster 节点上存储</li>
<li>请求对应的 cluster 节点</li>
</ul>
<p>cluster 节点收到数据后：</p>
<ul>
<li>校验一下这个 key 是否在当前 cluster 节点</li>
<li>如果在，那么处理客户端的请求即可</li>
<li>如果不在，读取本地缓存，确定这个 hash slot 在哪个 cluster 节点上存储，并发送 MOVE 错误给客户端，以重定向到正确的 cluster 节点</li>
</ul>
<h3 id="hash-tags">Hash Tags</h3>
<blockquote>
<p>There is an exception for the computation of the hash slot that is used in order to implement hash tags. Hash tags are a way to ensure that multiple keys are allocated in the same hash slot. This is used in order to implement multi-key operations in Redis Cluster.</p>
</blockquote>
<p>如果要存储一个 User 对象在 Redis 中，有可能像这样实现：</p>
<pre tabindex="0"><code>user:114514:name
user:114514:age
user:114514:sex
...
</code></pre><p>如果要获取一个 User 对象所有的成员的值，可能会这样做：</p>
<pre tabindex="0"><code>MGET user:114514:name, user:114514:age, user:114514:sex
</code></pre><p>如果这些 key 不在同一个 cluster 中，那么操作就很麻烦了</p>
<p>因此，为了 <strong>批量操作</strong> key，就要使用 hash tags 了</p>
<p>Redis Cluster 可以保证拥有相同的 hash tags 的 key，永远具有相同的 hash slots，这意味着会存储在相同的 cluster 节点中</p>
<p>使用 hash tags 的语法如下：</p>
<pre tabindex="0"><code>{&lt;key_prefix&gt;}&lt;key_suffix&gt;
</code></pre><p>这样，在计算 key 所属的 hash slots 时，就只会计算 <code>{}</code> 内部的部分，即 <code>CRC16(key_prefix) % 16384</code></p>
<p>对于上面的示例，可以这样设置 key：</p>
<pre tabindex="0"><code>{user:114514}.name
{user:114514}.age
{user:114514}.sex
</code></pre><h3 id="cluster-属性">Cluster 属性</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">redis-cli cluster nodes
</span></span><span class="line"><span class="cl">d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - <span class="m">0</span> <span class="m">1318428930</span> <span class="m">1</span> connected 0-1364
</span></span><span class="line"><span class="cl">3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - <span class="m">1318428930</span> <span class="m">1318428931</span> <span class="m">2</span> connected 1365-2729
</span></span><span class="line"><span class="cl">d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - <span class="m">1318428931</span> <span class="m">1318428931</span> <span class="m">3</span> connected 2730-4095
</span></span></code></pre></div><p>可以看到，一个 cluster node 具有以下基本属性：</p>
<ul>
<li>节点 id</li>
<li>ip 和 port（或者 host）</li>
<li>身份：master or slave</li>
<li>该节点最后一次被 ping 的时间戳</li>
<li>该节点最后一次收到 pong 的时间戳</li>
<li>config 的版本号</li>
<li>负责的 hash slots</li>
</ul>
<h3 id="cluster-bus">Cluster bus</h3>
<blockquote>
<p>Cluster bus protocol: a <strong>binary</strong> protocol composed of frames of different types and sizes. Every node is connected to every other node in the cluster using the cluster bus.</p>
</blockquote>
<p>Cluster bus 基于 gossip 协议，集群中，每个节点的通信通过 Cluster bus 进行</p>
<h4 id="cluster-bus-的作用">Cluster bus 的作用</h4>
<blockquote>
<p>Nodes use a gossip protocol to propagate information about the cluster in order to discover new nodes, to send ping packets to make sure all the other nodes are working properly, and to send cluster messages needed to signal specific conditions. The cluster bus is also used in order to propagate Pub/Sub messages across the cluster and to orchestrate manual failovers when requested by users (manual failovers are failovers which are not initiated by the Redis Cluster failure detector, but by the system administrator directly).</p>
</blockquote>
<ol>
<li><strong>节点发现</strong>：集群节点使用集群总线来发现集群中的其他节点。</li>
<li><strong>故障检测</strong>：集群总线用来交换定期的心跳消息，这些心跳包含故障检测消息，用于确定节点是否处于可达状态。</li>
<li><strong>配置更新</strong>：当集群配置发生变化时（如节点加入或离开集群），通过集群总线传播这些变化。</li>
<li><strong>投票和协商</strong>：在某些操作需要共识时（例如，当一个主节点无法达到时，选择一个副本来提升为新的主节点），集群总线用于投票和协商流程。</li>
<li><strong>公共订阅/发布消息的传播</strong>：集群总线还用于在集群各节点中传播订阅/发布（pub/sub）消息。</li>
</ol>
<p>总的来说，Cluster bus 就是提供一个 <strong>高效</strong> 的节点间交互方式</p>
<h4 id="开放的端口">开放的端口</h4>
<p>Cluster bus 开放的端口默认为 <code>RESP 开放的端口 + 10000</code></p>
<p>举个例子，RESP，即 Cluster Node 与 Client 通信的端口默认为 6379，那么 Cluster bus 的端口就是 16379</p>
<p>当然，也可以手动指定 cluster bus 的端口，修改 cluster-port 即可</p>
<h4 id="gossip-协议">gossip 协议</h4>
<p>Gossip 协议是一种在分布式系统中用于节点间通信的协议，它通过 <em>流言蜚语</em>（即 Gossiping）的方式来交换信息，从而实现信息的传播和一致性。</p>
<p>Gossip 协议与我们平常所说的流言传播相似，一个节点会 <strong>随机选择其他几个节点</strong> 分享信息，这些被选择的节点又会同样选择其他节点进行信息的传播，这样信息就 <strong>像病毒一样快速扩散开</strong> 来。</p>
<p>Gossip 的特点就是 <strong>去中心化</strong>，具有可伸缩性和鲁棒性</p>
<blockquote>
<p>为什么 Redis Cluster bus 要使用 gossip 协议呢？</p>
</blockquote>
<p>来看看 Redis 官方怎么说的：</p>
<blockquote>
<p>While Redis Cluster nodes form a full mesh, nodes <strong>use a gossip protocol</strong> and a configuration update mechanism in order <strong>to avoid exchanging too many messages</strong> between nodes during normal conditions, so the number of messages exchanged is not exponential.</p>
</blockquote>
<p>在一个大型集群中，如果节点需要以直接的方式交换状态信息或配置更新，那么每个节点都需要与其他每个节点进行通信。这意味着在 N 个节点的集群中，每个节点都需要发送 N-1 个消息来通知每个其他节点，总共就有 <code>N*(N-1)</code> 次通信。对于大型集群，这个数字会非常大，随着节点数目线性增加，需要的通信次数会以平方级别(N 的平方)增长</p>
<p>如果使用 gossip 协议，每个节点发送数据，仅仅会随机选择一些节点发送，然后慢慢传播开来，就像流言（病毒）传播一样，这样，整个集群内的消息数量处于一个可控范围，不会造成太大的压力</p>
<p>当然，gossip 协议存在 <strong>消息不及时</strong> 的缺点：消息在节点间传播是需要时间的，经过多个节点的转发，时效性不如直接发送好（不过大型集群，直接发送的压力太大，可能造成网络拥塞，时效性可能还不如 gossip）</p>
<h2 id="重定向与重新分片">重定向与重新分片</h2>
<h3 id="moved-redirection">MOVED Redirection</h3>
<p>前面提到了，如果客户端请求的数据不在某个 cluster 节点上，cluster 会给客户端发送重定向，告诉客户端应该请求哪个节点</p>
<p>事实上，重定向分为两种：</p>
<ul>
<li>临时重定向</li>
<li>永久重定向</li>
</ul>
<p>这里先说说永久重定向</p>
<p>永久重定向在 Redis Cluster 的语义为：该 key 的 hash slot 永久迁移到了另一个节点</p>
<p>永久重定向会发生在两种情况：</p>
<ul>
<li>这个 hash slot 本来就不是由当前 cluster 节点负责</li>
<li>这个 hash slot 原本由当前 cluster 节点负责，但是由于某种原因，迁移到了另一个节点</li>
</ul>
<p>cluster 节点发送永久重定向的过程：</p>
<ul>
<li>发送 <strong>MOVED</strong> message，包含了新的 cluster 的 ip 和 port</li>
<li>发送 cluster node 到 hash slots 的 <strong>映射关系</strong>（哈希表）给客户端</li>
</ul>
<p>客户端会更新（或者存储）映射关系到本地，并重新发起请求到正确的 cluster node</p>
<h3 id="resharding">Resharding</h3>
<p>添加一个节点的步骤：</p>
<ul>
<li><strong>添加一个新的节点</strong>：<code>redis-cli --cluster add-node &lt;new_host:new_port&gt; &lt;existing_host:existing_port&gt;</code></li>
<li><strong>分配散列插槽</strong>：<code>redis-cli --cluster reshard &lt;host:port&gt;</code>
其中，host:port 可以是集群中任意一个存在节点的 host:port</li>
</ul>
<p>reshard 的示例输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ redis-cli --cluster reshard 127.0.0.1:7000
</span></span><span class="line"><span class="cl">&gt;&gt;&gt; Performing Cluster Check <span class="o">(</span>using node 127.0.0.1:7000<span class="o">)</span>
</span></span><span class="line"><span class="cl">M: 50ae0f1a7e203a3fbb1a76a8af04b3f398e2f1e4 127.0.0.1:7000
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>0-5460<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">M: 2a0d96e5c41ac012b93c7c402769178d6ad8cfd3 127.0.0.1:7001
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>5461-10922<span class="o">]</span> <span class="o">(</span><span class="m">5462</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">M: b59c1b9f4557d17a6e6c9c4e0fd607a72bda5e60 127.0.0.1:7002
</span></span><span class="line"><span class="cl">   slots:<span class="o">[</span>10923-16383<span class="o">]</span> <span class="o">(</span><span class="m">5461</span> slots<span class="o">)</span> master
</span></span><span class="line"><span class="cl">How many slots <span class="k">do</span> you want to move <span class="o">(</span>from <span class="m">1</span> to 16384<span class="o">)</span>? <span class="m">1000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">What is the receiving node ID?
</span></span><span class="line"><span class="cl">Please <span class="nb">type</span> <span class="s2">&#34;help&#34;</span> <span class="k">if</span> you need help.
</span></span><span class="line"><span class="cl">Node ID: 2a0d96e5c41ac012b93c7c402769178d6ad8cfd3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Please enter all the <span class="nb">source</span> node IDs.
</span></span><span class="line"><span class="cl">  Type <span class="s1">&#39;all&#39;</span> to use all the nodes as <span class="nb">source</span> nodes <span class="k">for</span> the <span class="nb">hash</span> slots.
</span></span><span class="line"><span class="cl">  Type <span class="s1">&#39;done&#39;</span> once you entered all the nodes IDs and you want to start the rebalancing.
</span></span><span class="line"><span class="cl">Source node <span class="c1">#1:50ae0f1a7e203a3fbb1a76a8af04b3f398e2f1e4</span>
</span></span><span class="line"><span class="cl"><span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Ready to move <span class="m">1000</span> slots.
</span></span><span class="line"><span class="cl">  Source node: 50ae0f1a7e203a3fbb1a76a8af04b3f398e2f1e4
</span></span><span class="line"><span class="cl">  Destination node: 2a0d96e5c41ac012b93c7c402769178d6ad8cfd3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Moving slot <span class="m">1234</span> from 127.0.0.1:7000 to 127.0.0.1:7001: DONE
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">Moving slot <span class="m">1235</span> from 127.0.0.1:7000 to 127.0.0.1:7001: DONE
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl"><span class="o">(</span>Multiple lines indicating progress of slot migrations<span class="o">)</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl"><span class="o">[</span>OK<span class="o">]</span> Done
</span></span></code></pre></div><p>可以看出，reshard 需要指定源 cluster node 和目标 cluster node，以及要迁移的 hash slot 的数量</p>
<p>哈希槽的重分配过程如下：</p>
<ul>
<li>原节点设置为 MIGRATING 状态</li>
<li>新节点设置为 IMPORTING 状态</li>
<li>开始迁移哈希槽</li>
<li>迁移过程中，如果有新的客户端请求：
<ul>
<li>如果 key 存在，那么 <strong>在原节点执行</strong></li>
<li>否则，原节点会将请求 <strong>重定向</strong> 到新的节点，在新的节点执行</li>
</ul>
</li>
<li>迁移完成，新节点发送一个 OK 给原节点</li>
<li>原节点收到 OK 后，将迁移哈希槽的数据从本地 dataset 中删除</li>
</ul>
<h3 id="ask-redirection">ASK Redirection</h3>
<p>在 MOVED 永久重定向提了以下临时重定向</p>
<p>临时重定向，主要在迁移哈希槽过程中使用</p>
<p>迁移过程中，如果客户端执行的 key 在源节点不存在，那么就需要 <strong>临时重定向</strong> 到新节点来执行（没有必要在源节点执行，反正最终都要迁移到新节点）</p>
<p>源 Cluster 节点在收到一个 key 后，检查对应的 hash slot，如果这个 hash slot 不是由当前节点负责，那么直接发送 MOVED，否则：</p>
<ul>
<li>如果这个 hash slot 正在迁移，那么检查这个 key 是否是新 key：
<ul>
<li>如果是新 key，那么 <strong>临时重定向</strong> 到新的节点</li>
<li>否则正常返回</li>
</ul>
</li>
<li>否则正常返回</li>
</ul>
<p>临时重定向，就是发送一个 ASK message 给客户端，将请求临时重定向到新的节点</p>
<blockquote>
<p>为什么不直接使用 MOVED 重定向？</p>
</blockquote>
<blockquote>
<p>Why can&rsquo;t we simply use MOVED redirection? Because while MOVED means that we think the hash slot is permanently served by a different node and the next queries should be tried against the specified node. ASK means to send only the next query to the specified node.</p>
</blockquote>
<p>在迁移哈希槽的过程中，源节点负责的 hash slots <strong>暂时还没有发生改变</strong>，如果发送 MOVED message，那么客户端更新映射缓存，后续请求旧 key 就会跑到新的节点，但是 <strong>迁移可能还没有完成</strong>，如果还要正确执行：</p>
<ul>
<li>再重定向到源节点</li>
<li>或者等待迁移完毕</li>
</ul>
<p>无论哪种方式，效率都很低</p>
<h3 id="客户端连接和重定向处理">客户端连接和重定向处理</h3>
<p>前面已经基本将客户端连接和重定向处理到过程介绍了，这里再总结一下：</p>
<ul>
<li>客户端首次执行命令，由于映射缓存为空，往往会收到 MOVED 重定向，这时，可以将映射关系缓存到本地</li>
<li>以后执行命令，先计算 key 的 hash slot，然后查缓存获取目标 cluster node，最后执行请求</li>
<li>但缓存可能部分过期（集群由于某些原因发生了 Reshard），那么请求可能有三种情况：
<ul>
<li>当前请求的 key 对应的 hash slot 没有迁移，正常执行</li>
<li>当前请求的 key 对应的 hash slot 正在迁移：
<ul>
<li>如果是新 key，那么收到 ASK 重定向</li>
<li>否则正常执行</li>
</ul>
</li>
<li>当前请求的 key 对应的 hash slot 迁移完毕：收到 MOVED 重定向，更新缓存，重新执行请求</li>
</ul>
</li>
</ul>
<h3 id="redis-cluster-如何处理读写请求的分发">Redis Cluster 如何处理读写请求的分发</h3>
<blockquote>
<p>Normally replica nodes will <strong>redirect clients to the authoritative master</strong> for the hash slot involved in a given command</p>
</blockquote>
<p><strong>写请求分发到主节点：</strong></p>
<p>在 Redis Cluster 中，所有的写操作（如 SET, DEL, HSET 等）<strong>必须</strong> 由负责该键哈希槽的 <strong>主节点</strong> 处理。如果客户端尝试向从节点或错误的主节点发送写请求，它将收到一个 MOVED 重定向错误，指示正确的主节点地址。客户端需要重定向请求到指定的主节点。</p>
<p><strong>读请求分发到从节点：</strong></p>
<p>与写请求一样，读请求（如 GET, HGET 等）<strong>默认情况下也是发送到主节点</strong></p>
<p>假设主节点为 A，A 的从节点为 B，假设 key0 对应的 hash slot 由 A 管理</p>
<p>如果客户端向 B 发送一个读请求，B 会回应一个 MOVED 重定向错误，将客户端重定向到 A</p>
<p>但在 Redis Cluster 中可以设置从节点进行读取操作，以此来分担主节点的读取压力。</p>
<blockquote>
<p>however clients can use replicas in order to scale reads using the READONLY command.</p>
<p>READONLY tells a Redis Cluster replica node that the client is willing to read possibly stale data and is not interested in running write queries.</p>
</blockquote>
<p>要实现这一点，客户端可以使用 <code>READONLY</code> 命令通知从节点接受读请求。一旦进入只读模式，客户端就可以向该从节点发送读请求，读取存储在该节点的数据。</p>
<p>当客户端给从节点发送了 READONLY 命令后，从节点之后再收到读请求，只要这个 key 对应的 hash slot 由自己的 master 负责，那么就不会重定向客户端的请求，而是自己处理，降低 master 的压力</p>
<blockquote>
<p>注意：Redis Cluster 没有提供读请求的负载均衡（即将读请求均分到不同的从节点执行）</p>
<p>这意味着：<strong>如果要实现读请求的负载均衡，需要由客户端自己实现</strong></p>
<p>实现方式也很简单：</p>
<ul>
<li>客户端可以在建立连接时，获取整个集群的状态（master 有哪些，其下的 slave 有哪些）</li>
<li>然后可以实现不同的负载均衡策略，如轮询、分片等等，将请求路由到对应的从节点</li>
</ul>
</blockquote>
<p>当然，在从节点执行读请求，会遇到数据不一致的问题，这个就要看你的业务是否有强一致性需求了</p>
<h2 id="错误忍受fault-tolerance">错误忍受（Fault Tolerance）</h2>
<h3 id="心跳包heartbeat-packet">心跳包（Heartbeat Packet）</h3>
<p>为了检测整个集群的状态，节点间会定期地互相发送心跳包（Heartbeat Packet）</p>
<p>Redis 集群的节点通过发送和接收 ping 和 pong 包来不断交换信息，这两种包的结构相同，携带重要的配置信息，唯一的区别在于消息类型字段。我们将 ping 和 pong 包的组合称之为心跳包。</p>
<p>心跳包包含以下内容：</p>
<ul>
<li>类型：是 ping 还是 pong</li>
<li>Node ID</li>
<li>RESP 的 ip + port</li>
<li>Cluster bus 的 ip + port</li>
<li>版本号</li>
<li>当前节点的身份信息</li>
<li>包含的哈希槽</li>
<li>如果是从节点，还会记录主节点的 Node ID</li>
<li><strong>发送节点视角下的集群状态信息</strong>（包括 down 和 ok）</li>
</ul>
<p>简单来说，就是包含了节点本身的元数据，以及发送节点视角下的集群状态信息</p>
<blockquote>
<p>这里详细说一下 <strong>发送节点视角下的集群状态信息</strong>，对于后面理解 Redis Cluster 的错误检测会有帮助：</p>
<p>当一个节点发出心跳包时，它会在包里面包含它所观察到的集群状态的信息。这有助于其他节点获得关于集群健康状况的信息，比如：</p>
<ul>
<li>下线状态（down）：如果发送心跳包的节点观察到集群或者特定的节点出现了问题（比如无法达到或不再发送心跳信号），它会在心跳包中报告该节点或集群处于 down 状态。</li>
<li>正常状态（ok）：相反，如果发送心跳包的节点认为集群状态良好，所有节点都是活跃的并且响应心跳信号，那么它会报告集群状态是 ok 的。</li>
</ul>
<p>这样的设计能让集群中的其他节点根据接收到的心跳信息来更新自己的状态视图，从而使整个集群能够对节点失效做出快速响应，并相应地进行故障转移或重组。</p>
</blockquote>
<p><strong>发送机制</strong></p>
<ul>
<li>每个节点每秒会 <strong>随机</strong> ping 一些节点，这样每个节点发送的 ping 包数（及接收到的 pong 包数）<strong>是一个恒定的量</strong>，与集群中的节点数量无关。</li>
<li>每个节点都要确保 ping 那些超过一半的超时时间(NODE_TIMEOUT)还没有发送 ping 或接收 pong 的其他节点。在 NODE_TIMEOUT 时间到期之前，节点还会尝试重新连接 TCP 链路，以确保节点不因为当前 TCP 连接的问题而被认为是无法到达的。</li>
</ul>
<p>举个例子：</p>
<p>在一个有 100 个节点的集群中，如果节点超时时间设置为 60 秒，每个节点会尝试在 30s 内发送 99 个 ping 包，那么每秒就要发送 3.3 个 ping 包，整个集群 100 个节点，那么每秒就会产生 330 个 ping 包</p>
<p>虽然看起来很多，但是这些包都是均匀的分配到每一个节点，不会造成太大的负担</p>
<h3 id="错误检测">错误检测</h3>
<p>Redis 集群使用故障检测来识别当一个主节点或副本节点无法被集群大多数节点访问时的情形，并进行相应处理，例如提升一个副本成为新的主节点。如果无法执行故障转移（没有可用从节点），集群将进入错误状态，停止接收客户端查询。</p>
<p>节点会保存与其他节点相关的一系列标志。用于故障检测的有两个标志，称为 PFAIL（可能的故障）和 FAIL（确认故障）。PFAIL 是一个未被确认的故障类型，而 FAIL 意味着节点发生故障，并且这种状况已经被集群中大多数主节点在固定时间内确认。</p>
<p><strong>当节点超过 NODE_TIMEOUT 时间无法访问时，其他节点会给该节点标记 PFAIL。</strong> 无论是主节点还是副本节点，都可以为其它类型的节点标记 PFAIL。Redis 集群中节点不可达的概念是指我们发送了 ping，但在 NODE_TIMEOUT 时间内还未收到回复。</p>
<p>一个节点单独的 PFAIL 标志只是该节点关于其他节点的本地信息，不足以触发故障转移。要视为节点已经 down 掉，<strong>需要将 PFAIL 状态升级为 FAIL。</strong></p>
<blockquote>
<p>那么如何将 PFAIL 状态升级为 FAIL？</p>
</blockquote>
<p>升级需要满足三个条件：</p>
<ul>
<li>某节点（称为 A）将另一个节点（称为 B）标记为 PFAIL。</li>
<li>通过心跳检测机制，A 获取到了其它主节点对于 B 是否为 down 的意见</li>
<li>大多数的 <strong>有效</strong>（在 <code>NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT</code> 内报告 PFAIL 或者 FAIL 状态） 意见都认为这个节点为 down</li>
</ul>
<p>那么：</p>
<ul>
<li>节点 A 将 B <strong>标记为 FAIL</strong></li>
<li>给其它节点发送 FAIL message</li>
</ul>
<p>FAIL message 会强制其它节点将 B 标记为 FAIL</p>
<h3 id="从节点选举和升级过程">从节点选举和升级过程</h3>
<p>当一个主节点被标记为 FAIL，并且有可用的从节点，那么故障转移可以进行</p>
<p>故障转移的过程是这样的：</p>
<p>首先，每个从节点都是新的主节点的候选者</p>
<p>从节点会递增 currentEpoch（投票轮数）</p>
<p>每个从节点会通过 cluster bus 发送 FAILOVER_AUTH_REQUEST 包，请求其它主节点给自己投票</p>
<p>每个主节点在 <code>NODE_TIMEOUT * 2</code> 时间内，<strong>只有一次投票机会</strong>（防止多个从节点当选），当主节点收到 FAILOVER_AUTH_REQUEST 包后，如果有投票机会，就会给这个从节点投票（发送 FAILOVER_AUTH_ACK）</p>
<p>从节点会 <strong>抛弃</strong> 不属于当前 currentEpoch 的投票</p>
<p>当一个从节点收到大多数主节点的投票后，它就成为了新的主节点</p>
<p>如果超过 <code>NODE_TIMEOUT * 2</code> 时间，还没投票完毕，本轮投票失败，等待 <code>NODE_TIMEOUT * 4</code> 开启新的一轮投票</p>
<p>一旦选举出新的主节点，其他节点会被通知这一变更，确保整个集群中所有节点的配置信息保持一致。</p>
<h3 id="主节点重新加入集群的过程">主节点重新加入集群的过程</h3>
<blockquote>
<p>A master node will change its configuration to replicate (be a replica of) the node that stole its last hash slot.</p>
</blockquote>
<p>当一个主节点因为某些原因（例如网络分区或者服务崩溃）丢失了其所有的哈希槽，并且这些哈希槽被集群中的其他主节点接管之后，该节点在重新加入集群时将不再担任之前的主节点角色。</p>
<p>相反，它将更改其配置，成为接管了它 <strong>最后一个哈希槽的那个节点的副本</strong></p>
<blockquote>
<p>In general it may happen that A rejoins after a lot of time, in the meantime it may happen that hash slots originally served by A are served by multiple nodes, for example hash slot 1 may be served by B, and hash slot 2 by C.</p>
</blockquote>
<h3 id="副本迁移replica-migration">副本迁移（Replica migration）</h3>
<h4 id="intro">Intro</h4>
<p>在 <a href="#%e9%ab%98%e5%8f%af%e7%94%a8">高可用</a>
 这里简单提了一下副本迁移的好处</p>
<p>假设这种情况：</p>
<p><div class="not-prose">
<figure>
    <img src="http://images.blogs.skylee.top/2024-03-10-11-37-28-242.png"
      alt="image" 
      loading="lazy"
    >
  </figure></div>
</p>
<ul>
<li>master A 挂了，故障转移，slave A 成为新的主节点</li>
<li>slave A 也挂了，没有副本可用，<strong>整个集群服务不可用</strong></li>
</ul>
<p>为了进一步保证可用性，引入了「副本迁移」机制</p>
<p>如果一个主节点没有任何子节点，我们将其成为孤儿主节点</p>
<p>当集群中出现孤儿主节点，副本迁移机制就起作用了，它会将某一个主节点冗余的丛节点迁移到孤儿主节点，使其成为孤儿主节点的从节点：</p>
<p><div class="not-prose">
<figure>
    <img src="http://images.blogs.skylee.top/2024-03-10-11-45-32-166.png"
      alt="image" 
      loading="lazy"
    >
  </figure></div>
</p>
<ul>
<li>master A 挂了，故障转移，slave A 成为新的主节点</li>
<li>由于 slave A 为孤儿主节点，执行副本迁移，将 slaveC1 迁移，作为 slave A 的从节点</li>
<li>slave A 也挂了，故障转移，slave C1 成为新的主节点，<strong>集群仍然可用</strong></li>
</ul>
<h4 id="algorithm">Algorithm</h4>
<p>副本迁移的基本算法如下：</p>
<ul>
<li>当一个从节点检测到集群中出现至少一个孤儿主节点，开始尝试副本迁移</li>
<li>发现孤儿主节点的从节点可能有很多，但采取行动的从节点只有一部分</li>
<li>采取行动的从节点是：从节点数量最多的主节点中，不处于 FAIL 状态且节点 ID 最小的从节点。</li>
</ul>
<p>举个例子：</p>
<p><div class="not-prose">
<figure>
    <img src="http://images.blogs.skylee.top/2024-03-10-11-56-53-428.png"
      alt="image" 
      loading="lazy"
    >
  </figure></div>
</p>
<p>如果上面的节点都不是 FAIL 状态，那么会执行迁移过程的从节点为 slave2</p>
<p>可以通过配置 <code>cluster-migration-barrier</code> 来限制每个主节点最少具有的不处于 FAIL 状态的从节点数量</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://redis.io/docs/reference/cluster-spec/" target="_blank" rel="noopener">Redis cluster specification</a>
</li>
<li><a href="https://redis.io/commands/readonly/" target="_blank" rel="noopener">READONLY</a>
</li>
</ul>

    </article>

    



  </div>
</div>

  </main>
  <footer class="flex flex-none justify-center">
    <section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300">
  <div class="flex flex-row">
    
  
  
  
  
  
  
  
  
  
  
    <a href="https://github.com/SkyLee424" target="_blank" title="Github" class="flex flex-row mr-2">
      <span class="hidden">Github</span>
      <i class="h-6 w-6 flex-none"> <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path>
</svg>
 </i>
    </a>
  
  
  
    <a href="https://leetcode.cn/u/sky_lee/" target="_blank" title="LeetCode" class="flex flex-row mr-2">
      <span class="hidden">LeetCode</span>
      <i class="h-6 w-6 flex-none"> <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="96" height="96" viewBox="0 0 96 96" enable-background="new 0 0 24 24" xml:space="preserve">  <image id="image0" width="24" height="24" x="0" y="-1"
    href="data:image/png;base64,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" ></image>
</svg>
 </i>
    </a>
  
  


  </div>
  <div class="grow"></div>
  <div class="flex flex-row">
    <i class="h-6 w-6 flex-none"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path>
   <path d="M14 9.75a3.016 3.016 0 0 0 -4.163 .173a2.993 2.993 0 0 0 0 4.154a3.016 3.016 0 0 0 4.163 .173"></path>
</svg>
</i> 2024 Sky_Lee
    
  </div>
  
</section>

  </footer>
  <script src="/main.js"></script>

<div class="hidden top-1 right-1" id="code-copy">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" />
  <path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" />
</svg>

  </i>
</div>
<div class="hidden top-1 right-1" id="code-copy-done">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M5 12l5 5l10 -10" />
</svg>

  </i>
</div><script src="/code-copy.js"></script>





</body>
</html>
