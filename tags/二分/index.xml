<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二分 on Sky_Lee 的个人博客</title>
    <link>https://blogs.skylee.top/tags/%E4%BA%8C%E5%88%86/</link>
    <description>Recent content in 二分 on Sky_Lee 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Sky_Lee</copyright>
    <lastBuildDate>Sat, 06 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blogs.skylee.top/tags/%E4%BA%8C%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>树节点的第 K 个祖先</title>
      <link>https://blogs.skylee.top/posts/algorithm/binary-tree/lc.1483.-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%A5%96%E5%85%88/note/</link>
      <pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blogs.skylee.top/posts/algorithm/binary-tree/lc.1483.-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%A5%96%E5%85%88/note/</guid>
      <description>链接 常规解法 容易想到使用记忆化搜索： type TreeAncestor struct { memo [][]int // memo[node][k] parent []int n int } func Constructor(n int, parent []int) TreeAncestor { memo := make([][]int, n) for i := 0; i &amp;lt; n; i++{ memo[i] = make([]int, n) for j := 0; j &amp;lt; n; j++ { memo[i][j] = -2 } } return TreeAncestor{</description>
    </item>
  </channel>
</rss>
