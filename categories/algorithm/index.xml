<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Sky_Lee 的个人博客</title>
    <link>https://blogs.skylee.top/categories/algorithm/</link>
    <description>Recent content in Algorithm on Sky_Lee 的个人博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <copyright>Sky_Lee</copyright>
    <lastBuildDate>Thu, 11 Apr 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blogs.skylee.top/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>线段树</title>
      <link>https://blogs.skylee.top/posts/algorithm/segment-tree/note/</link>
      <pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blogs.skylee.top/posts/algorithm/segment-tree/note/</guid>
      <description>线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在 O(log N) 的时间复杂度内实现： 单点修改 区间修改 区间查询（区间求和，求区间最大值，求</description>
    </item>
    <item>
      <title>树节点的第 K 个祖先</title>
      <link>https://blogs.skylee.top/posts/algorithm/binary-tree/lc.1483.-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%A5%96%E5%85%88/note/</link>
      <pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://blogs.skylee.top/posts/algorithm/binary-tree/lc.1483.-%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%A5%96%E5%85%88/note/</guid>
      <description>链接 常规解法 容易想到使用记忆化搜索： type TreeAncestor struct { memo [][]int // memo[node][k] parent []int n int } func Constructor(n int, parent []int) TreeAncestor { memo := make([][]int, n) for i := 0; i &amp;lt; n; i++{ memo[i] = make([]int, n) for j := 0; j &amp;lt; n; j++ { memo[i][j] = -2 } } return TreeAncestor{</description>
    </item>
  </channel>
</rss>
